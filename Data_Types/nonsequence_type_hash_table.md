## 해시 테이블

### Hash Table : 해시 테이블은 키(Key)와 값(Value)을 짝지어 저장하는 자료 구조

### 해시 테이블의 원리

1. 키를 해시 함수를 통해 해시 값으로 변환
2. 변환된 해시 값을 인덱스로 삼아 데이터를 저장하거나 찾음
3. 이로 인해 검색, 삽입, 삭제를 매우 빠르게 시행

### 해시란?

- 임의의 크기를 가진 데이터를 고정된 크기의 고유한 값으로 변환하는 것
- 생성된 해시 값(고유한 정수)은 해당 데이터를 식별하는 ‘지문’ 역할을 함
- 파이썬에서는 이 해시 값을 이용해 해시 테이블에 데이터를 저장
- 이 변환을 수행하는 것이 **해시 함수**

### 해시 함수란?

- 임의 길이 데이터를 입력 받아 고정 길이(정수)로 변환해주는 함수. 이 ‘정수’가 바로 해시 값
- 주로 해시 테이블을 구현할 때, 매우 빠른 검색 및 데이터 저장 위치 결정을 위해 사용
- ‘해시 알고리즘’이라고도 부름
- TIP: 해시 테이블이 매우 빠른 이유
    - 해시 함수는 키(Key)를 입력 받아 데이터를 저장하거나 찾을 배열의 **‘정확한 인덱스’**를 **즉시** 계산합니다. → 검색이 필요 ㅇ
    - 마치 책의 제목(키)을 알면 색인(해시 함수)을 통해 페이지 번호(인덱스)를 바로 알아내고, 해당 페이지 (배열 위치)로 곧바로 이동하여 내용을 찾는 것과 같음

### set의 요소 & dict의 키와 해시 테이블의 관계

- set
    - 각 요소를 해시 함수로 변환해 나온 해시 값에 맞춰 해시 테이블 내부 버킷(bucket)에 위치 시킴
    - **그래서 “순서”라기 보다 “버킷 위치(인덱스)”가 요소의 위치를 결정**
    - 따라서 set은 순서를 보장하지 않음
- dict
    - 키(Key) → 해시 함수 → 해시 값 → 해시 테이블에 저장
    - 단 set와 달리 “삽입 순서”는 유지한다는 것이 언어 사양에 따라 보장 됨 (python 3.7 이상)
        - 즉, 키를 추가한 순서대로 반복문 순회할 때 나오게 됨
        - 사용자에게 보여지는 키 순서는 삽입 순서가 유지되도록 설계된 것

### set의 pop 메서드 예시 - 정수

- 정수(숫자) 값은 해시 값이 숫자 자기 자신과 동일하거나 단순 계산으로 **고정됨**
    
    ```python
    my_set = {3, 2, 1, 9, 100, 4, 87, 39, 10, 520}
    
    print(my_set.pop()) # 1
    print(my_set.pop()) # 2
    print(my_set.pop()) # 3
    print(my_set.pop()) # 100
    print(my_set.pop()) # 4
    print(my_set.pop()) # 39
    print(my_set.pop()) # 9
    print(my_set.pop()) # 10
    print(my_set.pop()) # 52
    print(my_set.pop()) # 87
    print(my_set) # set()
    ```
    
- 문자열은 해시 계산 시 파이썬의 **해시 난수화(Hash Randomization)**가 적용되므로, **실행마다 순서가 달라질 수 있음**
    
    ```python
    my_str_set = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j' }
    print(my_str_set.pop()) # a
    print(my_str_set.pop()) # f
    print(my_str_set.pop()) # h
    print(my_str_set.pop()) # e
    print(my_str_set.pop()) # d
    ```
    

### 파이썬에서의 해시 함수

- 정수
    - 같은 정수는 항상 같은 해시 값을 가짐
    - e.g. `hash(1)` 은 여러 번 호출해도 결과가 동일
- 문자열
    - 문자열 해시 시, 파이썬 인터프리터 시작 때 설정되는 난수 시드(seed)가 달라질 수 있음
    → 해시 함수가 실행될 때 마다 난수 시드(해시함수의 재료)가 달라짐
    - 보안상 이유로 해시 난수화 도입
    - 각 실행마다 달라질 수 있어 ‘a’의 해시 값도 매번 바뀔 수 있음
    
    ```python
    print(hash(1)) # 1
    print(hash(1)) # 1
    print(hash('a')) # 6847189658181194693 -> 해당 환경에서는 유지되지만 다시 정의할 때마다 
    계속 달라짐 -> ...
    print(hash('a')) # 6847189658181194693 -> 해당 환경에서는 유지 ...  : 어떤 bucket의 어떤 위치 주소
    ```
    

### 해시 난수화와 난수 시드

- **파이썬 프로세스가 새로 시작될 때마다** 해시를 계산할 때 사용하는 **난수 시드**가 달라짐
    - 해시 함수가 매번 바뀌는 것이 아니라, **해시 계산에 쓰이는 시드 값이 실행마다 달라**지는 것
- 이로 인해 동일한 데이터라도 매번 해시 값이 달라져 결과적으로 버킷 위치가 달라짐

### set의 요소 & dict의 키와 해시테이블 관계

- set의 pop()은 “임의의 요소”를 제거하고 반환함
    - 실행할 때마다 다른 요소를 얻는다는 의미에서의 “무작위”가 아니라
    ”임의”라는 의미에서의 “무작위” (By “arbitrary” the docs **don’t mean “random”**)
    - → 매번 달라지는 임의의 배치가 끝난 것들을 버킷의 순서대로 나오는 것이다.

### 내부적으로 해시 테이블(버킷)을 참조하기 때문에, 실행 때마다 다른 요소가 먼저 나올 수 있음

- 해시 난수화로 인해 문자열 같은 해시 값이 실행마다 달라질 수 있고,
따라서  set 내부 요소의 배치가 달라질 수 있음
- 정수는 해시 값이 항상 동일하기 때문에, 파이썬을 동일 프로세스에서 연속 실행할 때는 결과가 어느 정도 일정해 보이기도 하지만, 여전히 set은 순서가 없으므로 pop되는 순서는 예측 불가

### hashable

- hash() 함수에 넣어 해시 값을 구할 수 있는 객체를 의미
- 대부분의 **불변 타입**은 해시 가능
    - e.g. int, float, str, tuple(단, 내부에 불변만 있을 경우)
        
        ```python
        print(hash(1))
        print(hash(1.0))
        print(hash('1'))
        print(hash((1, 2, 3))) # 내부에 정수로 이루어져서 고정 값 사용
        ```
        
- 가변형 객체(e.g. list, dict, set)는 기본적으로 해시 불가능
    - 이유: 값이 변하면 해시 값도 달라질 수 있어 해시 테이블 무결성이 깨짐

### hashable과 불변성 간의 관계

- 해시 테이블(e.g. set, dict의 KEY)에는 hashable(해시가 가능한 객체)만 저장 가능
- 불변 객체는 생성 후 값 변경이 불가능하므로, 항상 같은 해시 값을 유지
→ 해시테이블이 안정적으로 동작
- 다만 “hash 가능하다 ! = 불변이다”가 절대적이지는 않지만
일반적으로 내장 자료형 기준에서는 불변이어야 해시 가능
- TIP: 가변 객체는 왜 hashable하지 않을까?
    - 해시 값의 불변성: 해시 테이블은 객체의 해시 값을 이용해 데이터를 저장하고 검색할 위치(인덱스)를 결정합니다.
    - **문제 발생**: 만약 list와 같은 가변 객체를 키로 사용하고, 그 리스트의 내용을 변경하면서 해시 값도 함게 변하게 됩니다.
    - **데이터 손실**: 이 경우 데이터를 저장했던 인덱스와 변경 후 찾으려는 인덱스가 달라져 해당 데이터를 영원히 찾을 수 없게 됩니다.
    - **결론**: 따라서 해시 테이블의 안정적인 동작을 보장하기 위해, 파이썬은 가변 객체의 해시 값 계산을 허용하지 않습니다.

### 가변형 객체가 hashable 하지 않은 이유

- 값이 변경될 수 있으므로, 같은 객체라도 값이 바뀌면 해시 값도 달라질 수 있음
- 해시 테이블에서는 “동일 키→ 동일 위치”로 가정하고 빠른 검색을 수행하는데, 이 가정이 깨짐
- e.g. 리스트, 집합, 딕셔너리 자체를 set이나 dict의 키로 쓸 수 없음
    
    ```python
    # TypeError: unhashable type: 'list'
    print(hash((1, 2, [3, 4])))
    # TypeError: unhashable type: 'list'
    print(hash([1, 2, 3]))
    # TypeError: unhashable type: 'list'
    my_set = {[1, 2, 3], 1, 2, 3, 4, 5}
    # TypeError: unhashable type: 'set'
    my_dict = {{3, 2}: 'a'}
    
    ```
    

### hashable 객체가 필요한 이유

1. 해시 테이블 기반 자료 구조 사용
    1. set의 요소, dict의키
    2. 중복 방지 & 빠른 검색, 조회
2. 불변성을 통한 일관된 해시 값
    1. 한 번 해시 값이 정해지면 바뀌지 않아야 해시 테이블 무결성이 유지
3. 안정성과 예측 가능성 유지
    1. 동일한 데이터는 항상 동일한 해시 값을 반환 → 로직을 단순화

### 해시 테이블 정리

- 해시 테이블은 해시 값을 인덱스로 삼아 데이터를 저장, 검색
- 파이썬의 set은 순서가 없고, pop() 시 어떤 요소가 반환될 지 정해져 있지않음
- dict는 파이썬 3.7+ 버전에서 삽입 순서가 보장되지만, 내부 구현은 여전히 해시 테이블
- 해시 함수는 정수/문자열 등 타입에 따라 다르게 동작하며, 문자열 해시 시 난수화로 실행마다 달라질 수 있음
- hashable(해시가 가능한 객체) 객체만 set과 dict의 키로 사용 가능하며, 일반적으로 불변 타입이 이에 해당