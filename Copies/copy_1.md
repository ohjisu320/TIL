# 복사

## 객체와 참조

### 가변/불변 객체의 개념

- 객체 복사의 핵심을 파악하려면, 파이썬 자료구조의 가변과 불변 두 가지 종류를 살펴봐야 함
- Mutable(가변) 객체
    - 생성 후 내용을 변경할 수 **있는** 객체
        - 예: list, dict, set
- Immutable (불변) 객체
    - 생성 후 내용을 변경할 수 **없는** 객체
        - 예: int, float, str, tuple

### 변수 할당의 의미

- 파이썬에서 변수 할당은 객체에 대한 참조를 생성하는 과정
    - 변수는 객체의 메모리 주소를 가리키는 **Label** 역할을 함
    - `=` 연산자를 사용하여 변수에 값을 할당
        - 할당 시 새로운 객체가 생성되거나 **기존 객체에 대한 참조가 다시 생성**됨

### `id()`  함수를 사용한 메모리 주소 확인

- `id()` 함수를 사용하여 객체의 메모리 주소를 확인 가능
- `is` 연산자를 통해 두 변수가 같은 객체를 참조하는지 확인 가능

### 가변/불변 메모리 관리 방식

- 가변 객체
    - 생성 후에도 그 내용을 수정할 수 있음
    - 객체의 내용이 변경되어도 같은 메모리 주소를 유지
- 불변 객체
    - 생성 후 그 값을 변경할 수 없음
    - 새로운 값을 할당하면 새로운 객체가 생성되고, 변수는 새 객체를 참조하게 됨

### 가변/불변 메모리 관리 방식의 이유

- 성능 최적화
    - 불변 객체: 변경이 불가능하므로, **여러 변수가 동일한 객체**를 **안전하게 공유**할 수 있음
    - 가변 객체: 내용 수정이 빈번할 때, 새로운 객체를 생성하는 대신 **기존 객체를 직접 수정**할 수 있음.
    이로 인해 **객체 생성 및 삭제에 드는 비용을 절감**하여 **성능을 향상**시킴
- 메모리 효율성
    - 불변 객체: 동일한 값을 가진 여러 변수가 같은 객체를 참조할 수 있어 **메모리 사용을 최소화**할 수 있음
    - 가변 객체: 크기가 큰 데이터를 효율적으로 수정할 수 있음

## 얕은 복사

### 얕은 복사 (Shallow Copy) : 객체의 최상위 요소만 새로운 메모리에 복사하는 방법

- 내부에 중첩된 객체가 있다면 그 객체의 참조만 복사됨
- 모습만 똑같고 다른 메모리 주소를 가리
- **TIP**: 얕은 복사의 함정, **‘가변 객체’**
    - 얕은 복사 후 중첩된 **리스트나 딕셔너리 같은** 가변 객체를 수정하면 **원본 객체와 복사본 객체가 함께 변경**됨
    - 이는 복사본의 중첩 객체가 **여전히 원본 객체의 중첩 객체를 참조**하고 있기 때문!

### 얕은 복사 구현 방법

1. 리스트 슬라이싱
    
    ```python
    # 1차원 리스트에서의 얕은 복사 (리스트 슬라이싱)
    a = [1, 2, 3]
    b = a[:]
    
    print(a)  # [1, 2, 3]
    print(b)  # [1, 2, 3]
    ```
    
2. `copy()` 메서드
    
    ```python
    # 1차원 리스트에서의 얕은 복사 (copy 메서드)
    a = [1, 2, 3]
    b = a.copy()
    
    print(a)  # [1, 2, 3]
    print(b)  # [1, 2, 3]
    ```
    
3. `list()` 함수
    
    ```python
    # 1차원 리스트에서의 얕은 복사 (list() 함수)
    a = [1, 2, 3]
    d = list(a)
    a[0] = 100
    
    print(a)  # [100, 2, 3]
    print(d)  # [1, 2, 3]
    ```
    

### 얕은 복사의 한계

- 2차원 리스트와 같이 변경 가능한 객체 안에 변경 가능한 객체가 있는 경우
    - a와 b의 주소는 다르지만 내부 객체의 주소는 같이 때문에 함께 변경됨

### 1차원 리스트와 다차원 리스트에서의 차이점

- **1차원 리스트**
    - 얕은 복사로 **충분히 독립적**인 복사본을 만들 수 있음
- **다차원 리스트**
    - 최상위 리스트만 복사되고, **내부 리스트는 여전히 원본과 같은 객체를 참조**
    - a의 메모리주소를 복사한 b의 내부 요소를 일부 변경하면  a와 다른 모양을 하지만
    메모리주소가 같기에 변경하지 않은 요소 `a[2]`  에 한해선 `a[2] == b[2]`
        
        ```python
        # 얕은 복사의 한계
        print('\n다차원 리스트 얕은 복사의 한계')
        a = [1, 2, [3, 4, 5]]
        b = a[:] # 겉만 복사
        b[0] = 999
        
        print(a)  # [1, 2, [3, 4, 5]]
        print(b)  # [999, 2, [3, 4, 5]]
        
        a[2][1] = 100 # a와 b 둘 다 영향을 받음
        
        print(a)  # [1, 2, [3, 100, 5]]
        print(b)  # [999, 2, [3, 100, 5]]
        
        print(f'a[2]와 b[2]가 같은 객체인가? {a[2] is b[2]}')  # True 같은 내부 리스트를 가리킴
        
        ```
        
        | 항목 | 설명 |
        | --- | --- |
        | `a[:]` | 겉만 복사 (얕은 복사) |
        | `a[0] is b[0]` | False (정수니까 값만 복사됨) |
        | `a[2] is b[2]` | True  (같은 내부 리스트를 가리킴) |
        | 내부 리스트 변경 | a와 b 둘 다 영향을 받음 |
        

# 깊은 복사

## 깊은 복사 - 이론

### 깊은 복사(Deep Copy) : 객체의 모든 수준의 요소를 새로운 메모리에 복사하는 방법

- 중첩된 객체까지 모두 새로운 객체로 생성됨
- TIP: 완전한 독립성 보장
    - 깊은 복사는 원본 객체와 복사본이 완전히 독립적임을 보장
    - 복사본의 어떤 수준에 있는 중된 내용을 변경하더라도 원본 객체에는 절대 영향을 주지 않음

### 깊은 복사 구현 방법

- `copy` 모듈에서 제공하는 `deepcopy()` 함수를 사용
    
    ```python
    # 깊은 복사
    import copy
    
    print('깊은 복사 예시')
    a = [1, 2, [3, 4, 5]]
    b = copy.deepcopy(a)
    
    print(a)  # [1, 2, [3, 4, 5]]
    print(b)  # [1, 2, [3, 100, 5]]
    print(f'a[2]와 b[2]가 같은 객체인가? {a[2] is b[2]}')  # False
    
    ```
    

### 깊은 복사 예시

- 중첩된 객체에서의 깊은 복사
    
    ```python
    # 복잡한 중첩 객체 예시
    print('복잡한 중첩 객체 깊은 복사')
    original = {
        'a': [1, 2, 3],
        'b': {'c': 4, 'd': [5, 6]},
    }
    copied = copy.deepcopy(original)
    
    copied['a'][1] = 100
    copied['b']['d'][0] = 500
    
    print(f'원본: {original}')  # {'a': [1, 2, 3], 'b': {'c': 4, 'd': [5, 6]}}
    print(f'복사본: {copied}')  # {'a': [1, 100, 3], 'b': {'c': 4, 'd': [500, 6]}}
    print(
        f"original['b']와 copied['b']가 같은 객체인가? {original['b'] is copied['b']}"
    )  # False
    
    ```